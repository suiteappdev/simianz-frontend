/*  weak */

//region Imports
// $FlowFixMe
'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _require = require('live-log')('live-callbacks');

var log = _require.log;
var error = _require.error;
var warn = _require.warn;
var debug = _require.debug;

//endregion

var Event = (function () {
  function Event(name, app) {
    var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    var callInfo = _ref.callInfo;
    var moduleName = _ref.moduleName;
    var fn = _ref.fn;

    _classCallCheck(this, Event);

    this.name = name;
    this.app = app;
    this.callbacks = { before: [], after: [] };
    // Callsite info.
    _Object$assign(this, { callInfo: callInfo, moduleName: moduleName, fn: fn });
  }

  _createClass(Event, [{
    key: 'desc',
    value: function desc(description) {
      this.description = description;
      return this;
    }
  }, {
    key: 'run',
    value: function run(opts, performFn) {
      var fn;
      return _regeneratorRuntime.async(function run$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (this.name) {
              context$2$0.next = 2;
              break;
            }

            return context$2$0.abrupt('return', error('Event name not set'));

          case 2:
            fn = undefined;

            if (performFn) {
              fn = performFn;
            } else {
              fn = this.fn ? this.fn : function callee$2$0(opts, beforeResults) {
                return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                  while (1) switch (context$3$0.prev = context$3$0.next) {
                    case 0:
                      return context$3$0.abrupt('return', beforeResults);

                    case 1:
                    case 'end':
                      return context$3$0.stop();
                  }
                }, null, _this);
              };
            }
            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(this.app._perform(this.name, opts, fn));

          case 6:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 7:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * @param {string} stage - when the hooks should run. E.g. `before`, `after`.
     * @param {Object} opts
     * @param {string} opts.source - Used to determine whether this called as a hook on a previous event.
     */
  }, {
    key: 'runHooks',
    value: function runHooks(stage, opts) {
      var source, results, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, callback, result;

      return _regeneratorRuntime.async(function runHooks$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (this.callbacks[stage]) {
              context$2$0.next = 3;
              break;
            }

            warn('No hooks for stage \'' + stage + '\' of event \'' + this.name + '\'');
            return context$2$0.abrupt('return');

          case 3:
            source = this.name;
            results = [];
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            context$2$0.prev = 8;
            _iterator = _getIterator(this.callbacks[stage]);

          case 10:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              context$2$0.next = 21;
              break;
            }

            callback = _step.value;

            //this.vent.emit('runHook', stage, name, callInfo)
            //await exec(fn, opts)
            opts.source = source;
            opts.stage = stage;
            context$2$0.next = 16;
            return _regeneratorRuntime.awrap(callback.run(opts));

          case 16:
            result = context$2$0.sent;

            results.push(result);

          case 18:
            _iteratorNormalCompletion = true;
            context$2$0.next = 10;
            break;

          case 21:
            context$2$0.next = 27;
            break;

          case 23:
            context$2$0.prev = 23;
            context$2$0.t0 = context$2$0['catch'](8);
            _didIteratorError = true;
            _iteratorError = context$2$0.t0;

          case 27:
            context$2$0.prev = 27;
            context$2$0.prev = 28;

            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }

          case 30:
            context$2$0.prev = 30;

            if (!_didIteratorError) {
              context$2$0.next = 33;
              break;
            }

            throw _iteratorError;

          case 33:
            return context$2$0.finish(30);

          case 34:
            return context$2$0.finish(27);

          case 35:
            return context$2$0.abrupt('return', results);

          case 36:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[8, 23, 27, 35], [28,, 30, 34]]);
    }
  }, {
    key: 'addCallback',
    value: function addCallback(stage, cb) {
      this.callbacks[stage].push(cb);
      return this;
    }

    //
    // Legacy
    //

  }, {
    key: 'get',
    value: function get() {
      var args$2$0 = arguments;
      return _regeneratorRuntime.async(function get$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.run.apply(this, args$2$0));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'fire',
    value: function fire() {
      var args$2$0 = arguments;
      return _regeneratorRuntime.async(function fire$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.run.apply(this, args$2$0));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }]);

  return Event;
})();

exports.Event = Event;

// Forward results from before hooks, if there is not a perform fn.
//# sourceMappingURL=event.js.map
