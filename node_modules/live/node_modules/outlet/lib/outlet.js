/*  weak */

//region Imports
// $FlowFixMe
'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _extends = require('babel-runtime/helpers/extends')['default'];

var _toArray = require('babel-runtime/helpers/to-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _eventemitter3 = require('eventemitter3');

var _eventemitter32 = _interopRequireDefault(_eventemitter3);

var _arguejs = require('arguejs');

var _arguejs2 = _interopRequireDefault(_arguejs);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _uniqueid = require('uniqueid');

var _uniqueid2 = _interopRequireDefault(_uniqueid);

// $FlowFixMe

var _liveCaller = require('live-caller');

var _event = require('./event');

//endregion

var _require = require('live-log')('live-callbacks');

var log = _require.log;
var error = _require.error;
var warn = _require.warn;
var debug = _require.debug;

var Outlet = (function () {
  function Outlet() {
    var container = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Outlet);

    _lodash2['default'].defaults(container, {
      events: {},
      state: {},
      vent: new _eventemitter32['default']()
    });

    this.container = container;
    this.events = container.events;
    this.state = container.state;
    this.vent = container.vent;
  }

  _createClass(Outlet, [{
    key: 'runHooks',
    value: function runHooks(stage, name) {
      var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
      var event, results;
      return _regeneratorRuntime.async(function runHooks$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            event = this.events[name];

            if (event) {
              context$2$0.next = 4;
              break;
            }

            console.warn('Event was not found: \'' + name + '\'');
            return context$2$0.abrupt('return');

          case 4:
            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(event.runHooks(stage, opts));

          case 6:
            results = context$2$0.sent;
            return context$2$0.abrupt('return', results);

          case 8:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'getOrCreateEvent',
    value: function getOrCreateEvent(name) {
      return this.events[name] = this.events[name] || new _event.Event(name, this);
    }
  }, {
    key: 'addHook',
    value: function addHook(stage, _ref) {
      var name = _ref.name;
      var opts = _ref.opts;
      var fn = _ref.fn;

      var callInfo = (0, _liveCaller.getCallerFile)(3);
      var event = this.getOrCreateEvent(name);

      var callback = this.getOrCreateEvent('anon' + (0, _uniqueid2['default'])());
      callback.callInfo = callInfo;
      callback.moduleName = this.moduleName;
      callback.fn = fn;

      this.vent.emit('add-callback', name, callback);
      event.addCallback(stage, callback);
      return callback;
    }
  }, {
    key: 'perform',
    value: function perform(_name, _opts, _fn) {
      var _2,
          name,
          opts,
          fn,
          callInfo,
          args$2$0 = arguments;

      return _regeneratorRuntime.async(function perform$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _2 = (0, _arguejs2['default'])({ name: String, opts: [Object, {}], fn: [Function] }, args$2$0);
            name = _2.name;
            opts = _2.opts;
            fn = _2.fn;
            callInfo = (0, _liveCaller.getCallerFile)(2);
            context$2$0.next = 7;
            return _regeneratorRuntime.awrap(this._perform(name, _extends({ callInfo: callInfo }, opts), fn));

          case 7:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: '_perform',
    value: function _perform(_name, _opts, _fn) {
      var _3,
          name,
          opts,
          fn,
          beforeResults,
          result,
          afterResults,
          args$2$0 = arguments;

      return _regeneratorRuntime.async(function _perform$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _3 = (0, _arguejs2['default'])({ name: String, opts: [Object, {}], fn: [Function] }, args$2$0);
            name = _3.name;
            opts = _3.opts;
            fn = _3.fn;

            this.vent.emit('start-perform', name, opts);
            context$2$0.next = 7;
            return _regeneratorRuntime.awrap(this.runHooks('before', name, opts));

          case 7:
            beforeResults = context$2$0.sent;

            this.vent.emit('run-event', name, opts);
            result = null;

            if (!fn) {
              context$2$0.next = 14;
              break;
            }

            context$2$0.next = 13;
            return _regeneratorRuntime.awrap(fn(opts, beforeResults));

          case 13:
            result = context$2$0.sent;

          case 14:
            context$2$0.next = 16;
            return _regeneratorRuntime.awrap(this.runHooks('after', name, opts));

          case 16:
            afterResults = context$2$0.sent;
            return context$2$0.abrupt('return', result);

          case 18:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    // Defines an event that handlers can be added to.
  }, {
    key: 'event',
    value: function event(name) {
      return this.getOrCreateEvent(name);
    }

    // TODO: Should we store lifecycle events for each event, or store events with a naming convention.
    // E.g. `app.on('before:some:event')` OR `app.before('some:event')`.
    // Two parts: Implementation and API.
  }, {
    key: 'on',
    value: function on(_name, _opts, _fn) {
      // TODO: Allow `before:event` sugar.
      //if (const rest = hasBeforePrefix(name)) return this.addHook('before', opts, ...rest.join(''))
      this.addHook('after', parseParams(arguments));
    }

    //register(name, opts, fn, done) {
    //
    //  const {before, after, ...rest} = opts
    //
    //  // Wrap function in perform function to trigger hooks.
    //  const performFn = this.perform.bind(this, name, opts, fn)
    //
    //  // TODO(vjpr): Only supports 1 before hook. Should support array.
    //  if (before) {
    //    this.addHook('before', {name: before[0], opts, fn: performFn})
    //    return
    //  }
    //
    //  if (after) {
    //    this.addHook('after', {name: after[0], opts, fn: performFn})
    //    return
    //  }
    //
    //}

  }, {
    key: 'before',
    value: function before(_name, _opts, _fn) {
      return this.addHook('before', parseParams(arguments));
    }
  }, {
    key: 'after',
    value: function after(_name, _opts, _fn) {
      return this.addHook('after', parseParams(arguments));
    }

    //
    // Legacy
    //

  }, {
    key: 'reply',
    value: function reply(_name, _opts, _fn) {
      return this.addHook('before', parseParams(arguments));
    }

    // TODO: instead of logging with prefix `before`, use `provide`.
  }, {
    key: 'provide',
    value: function provide(_name, _opts, _fn) {
      return this.addHook('before', parseParams(arguments));
    }

    //consumes(_name, _opts, _fn) {
    //  return this.addHook('after', parseParams(arguments))
    //}

  }, {
    key: 'consume',
    value: function consume(name) {
      return this.event(name);
    }

    // ---

  }]);

  return Outlet;
})();

exports.Outlet = Outlet;

function parseParams(args) {
  return (0, _arguejs2['default'])({ name: String, opts: [Object], fn: Function }, args);
}

function hasBeforePrefix(name) {
  // $FlowFixMe

  var _name$split = name.split(':');

  var _name$split2 = _toArray(_name$split);

  var first = _name$split2[0];

  var rest = _name$split2.slice(1);

  // $FlowFixMe
  if (first === 'before') return rest;
  return false;
}
// TODO: Need to find the first non-regenerator for live-app perform.
//# sourceMappingURL=outlet.js.map
