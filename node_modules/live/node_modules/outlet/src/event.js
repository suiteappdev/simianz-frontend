/* @flow weak */

//region Imports
// $FlowFixMe
const {log, error, warn, debug} = require('live-log')('live-callbacks')
//endregion

export class Event {

  name: string;
  app: any;
  callbacks: any;
  callInfo: any;
  moduleName: any;
  fn: any;
  description: any;

  constructor(name: string, app: any, {callInfo, moduleName, fn} = {}) {
    this.name = name
    this.app = app
    this.callbacks = {before: [], after: []}
    // Callsite info.
    Object.assign(this, {callInfo, moduleName, fn})
  }

  desc(description) {
    this.description = description
    return this
  }

  async run(opts, performFn) {
    if (!this.name) return error('Event name not set')
    // Forward results from before hooks, if there is not a perform fn.
    let fn
    if (performFn) {
      fn = performFn
    } else {
      fn = this.fn ? this.fn : async (opts, beforeResults) => { return beforeResults }
    }
    return await this.app._perform(this.name, opts, fn)
  }

  /**
   * @param {string} stage - when the hooks should run. E.g. `before`, `after`.
   * @param {Object} opts
   * @param {string} opts.source - Used to determine whether this called as a hook on a previous event.
   */
  async runHooks(stage: string, opts: {source: any, stage: any}) {
    if (!this.callbacks[stage]) {
      warn(`No hooks for stage '${stage}' of event '${this.name}'`)
      return
    }
    const source = this.name
    let results = []
    for (let callback of this.callbacks[stage]) {
      //this.vent.emit('runHook', stage, name, callInfo)
      //await exec(fn, opts)
      opts.source = source
      opts.stage = stage
      const result = await callback.run(opts)
      results.push(result)
    }
    return results
  }

  addCallback(stage, cb) {
    this.callbacks[stage].push(cb)
    return this
  }

  //
  // Legacy
  //

  async get(...args) {return await this.run(...args)}

  async fire(...args) {return await this.run(...args)}

}
