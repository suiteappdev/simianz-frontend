/* @flow weak */

//region Imports
// $FlowFixMe
const {log, error, warn, debug} = require('live-log')('live-callbacks')
import path from 'path'
import EventEmitter from 'eventemitter3'
import __ from 'arguejs'
import _ from 'lodash'
import uniqueid from 'uniqueid'
// $FlowFixMe
import {getCallerFile, makeIDELink} from 'live-caller'
import {Event} from './event'
//endregion

export class Outlet {

  container;
  state;
  events;
  vent;
  moduleName;

  constructor(container = {}) {

    _.defaults(container, {
      events: {},
      state: {},
      vent: new EventEmitter,
    })

    this.container = container
    this.events = container.events
    this.state = container.state
    this.vent = container.vent

  }

  async runHooks(stage, name, opts = {}) {
    const event = this.events[name]
    if (!event) {
      console.warn(`Event was not found: '${name}'`)
      return
    }
    const results = await event.runHooks(stage, opts)
    return results
  }

  getOrCreateEvent(name) {
    return this.events[name] = this.events[name] || new Event(name, this)
  }

  addHook(stage, {name, opts, fn}) {
    const callInfo = getCallerFile(3)
    const event = this.getOrCreateEvent(name)

    const callback = this.getOrCreateEvent(`anon${uniqueid()}`)
    callback.callInfo = callInfo
    callback.moduleName = this.moduleName
    callback.fn = fn

    this.vent.emit('add-callback', name, callback)
    event.addCallback(stage, callback)
    return callback
  }

  async perform(_name, _opts, _fn) {
    const {name, opts, fn} = __({name: String, opts: [Object, {}], fn: [Function]}, arguments)
    const callInfo = getCallerFile(2) // TODO: Need to find the first non-regenerator for live-app perform.
    await this._perform(name, {callInfo, ...opts}, fn)
  }

  async _perform(_name, _opts, _fn) {
    const {name, opts, fn} = __({name: String, opts: [Object, {}], fn: [Function]}, arguments)
    this.vent.emit('start-perform', name, opts)
    const beforeResults = await this.runHooks('before', name, opts)
    this.vent.emit('run-event', name, opts)
    let result = null
    if (fn) result = await fn(opts, beforeResults)
    const afterResults = await this.runHooks('after', name, opts)
    return result
  }

  // Defines an event that handlers can be added to.
  event(name) {
    return this.getOrCreateEvent(name)
  }

  // TODO: Should we store lifecycle events for each event, or store events with a naming convention.
  // E.g. `app.on('before:some:event')` OR `app.before('some:event')`.
  // Two parts: Implementation and API.
  on(_name, _opts, _fn) {
    // TODO: Allow `before:event` sugar.
    //if (const rest = hasBeforePrefix(name)) return this.addHook('before', opts, ...rest.join(''))
    this.addHook('after', parseParams(arguments))
  }

  //register(name, opts, fn, done) {
  //
  //  const {before, after, ...rest} = opts
  //
  //  // Wrap function in perform function to trigger hooks.
  //  const performFn = this.perform.bind(this, name, opts, fn)
  //
  //  // TODO(vjpr): Only supports 1 before hook. Should support array.
  //  if (before) {
  //    this.addHook('before', {name: before[0], opts, fn: performFn})
  //    return
  //  }
  //
  //  if (after) {
  //    this.addHook('after', {name: after[0], opts, fn: performFn})
  //    return
  //  }
  //
  //}

  before(_name, _opts, _fn) {
    return this.addHook('before', parseParams(arguments))
  }

  after(_name, _opts, _fn) {
    return this.addHook('after', parseParams(arguments))
  }

  //
  // Legacy
  //

  reply(_name, _opts, _fn) {
    return this.addHook('before', parseParams(arguments))
  }

  // TODO: instead of logging with prefix `before`, use `provide`.
  provide(_name, _opts, _fn) {
    return this.addHook('before', parseParams(arguments))
  }

  //consumes(_name, _opts, _fn) {
  //  return this.addHook('after', parseParams(arguments))
  //}

  consume(name) {
    return this.event(name)
  }

  // ---

}

function parseParams(args) {
  return __({name: String, opts: [Object], fn: Function}, args)
}

function hasBeforePrefix(name) {
  // $FlowFixMe
  const [first, ...rest] = name.split(':')
  // $FlowFixMe
  if (first === 'before') return rest
  return false
}
