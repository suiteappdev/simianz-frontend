//region Imports
import locator from '../locator'
import path from 'path'
import chalk from 'chalk'
import s from 'string'
import _ from 'lodash'
import Dict from 'core-js/library/fn/dict'
import {Outlet} from 'outlet'
import isNode from 'is-node'
import EventEmitter from 'eventemitter3'
//endregion

const useDynamicRequire = false

export class PluginLoader {

  constructor(container) {
    this.container = container
    _.defaults(this.container, {
      vent: new EventEmitter,
      state: {},
    })
  }

  loadPlugins() {

    let {files, dynamicRequire} = this.getPluginFiles(this.container)

    _(files).each((f) => {
      const rawModule = this.requireModule(f, dynamicRequire)
      this.register(rawModule, f)
    }).run()

    // TODO: Files are two different things (webpack or node path). Change this.
    return files

  }

  register(rawModule, fullPath = null) {

    const {module, registerFn} = this.getLiveModule(rawModule)

    // Invalid module.
    if (!module) {
      const text = (fullPath ? fullPath : '\n' + rawModule.toString())
      this.container.vent.emit('invalid-module', text)
      return
    }

    // Set module name, if it doesn't exist.
    if (!module.$name) module.$name = this.getModuleName(fullPath, module)

    this.printPlugin(fullPath, module.$name)

    this.registerLiveModule({module, registerFn})

  }

  ///
  /// Allows us to support a variety of Live module formats.
  ///
  /// We need to do two things with modules.
  /// - Read meta-data from the module.
  /// - Pass the Live application instance to a registration function.
  ///
  /// @param {} module - the result of a `require(...)` call.
  /// @returns {object} obj
  /// @returns {object} obj.module - the instantiated Live module.
  /// @returns {Function} obj.registerFn - function which is passed the Live application instance.
  ///
  getLiveModule(rawModule) {

    // Plain object.
    if (rawModule.register) return {module: rawModule, registerFn: rawModule.register}

    // Class.
    if (rawModule.prototype) {
      if (!rawModule.prototype.register) return {module: null}
      const liveModule = new rawModule
      return {module: liveModule, registerFn: liveModule.register}
    }

    // Function.
    if (_.isFunction(rawModule)) {
      return {module: rawModule, registerFn: rawModule}
    }

    return {module: null}

  }

  getModuleName(fullPath, module) {
    if (module.name) return module.name
    if (fullPath) {
      //if (!isNode) return null
      return path.basename(path.dirname(fullPath)) // TODO: Double check this works for webpack - context.keys()! Maybe we can get more info from the context.)
    } else {
      return null
    }
  }

  //
  // Register a module.
  //
  // Calls the register method on a module.
  //
  registerLiveModule({module, registerFn}) {

    const moduleName = module.$name

    // Create a namespace for each module in our `state` variable in our container.

    this.createContainerStateNamespace(moduleName)

    // Register plugin.

    const live = new Outlet(this.container)
    live.moduleName = moduleName
    registerFn.call(module, live)

  }

  createContainerStateNamespace(moduleName) {
    if (moduleName) {
      const ns = s(moduleName).camelize()
      // Multiple modules maybe be registered under one namespace when using `live.shared.js`.
      if (!this.container.state[ns]) this.container.state[ns] = {}
    } else {
      throw new Error('You must provide a name for your plugin. Add a `$name` property to the live file.')
    }
  }

  requireModule(f) {
    if (__CLIENT__) {
      // Plugins will already be setup on window object.
      console.log('Requiring module:', f)
      return window.livePlugins[f]
    } else {
      return require('./node')(f)
    }
  }

  getPluginFiles() {
    let files
    if (__CLIENT__) {
      // NOTE: This file is generated on webpack build.
      //const livePlugins = require('generated/live-browser-plugin-requires-generated')
      const livePlugins = window.livePlugins // Alternative.
      console.log('Found Live Plugins', livePlugins)
      files = Object.keys(livePlugins)
    } else {
      files = locator()
    }
    return {files}
  }

  getRawModules(files) {

  }

  // TODO(vjpr): Add an explanation of how this works. Reading from the top should
  // explain everything. Who calls what and from where.

  printPlugin(fullPath, moduleName) {
    const relPath = fullPath ? path.relative(process.cwd(), fullPath) : ''
    this.container.vent.emit('register-plugin', {moduleName, relPath})
  }

}
